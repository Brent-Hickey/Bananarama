%% -------------------------------------------------------------------
%%
%% Copyright (c) 2013 Basho Technologies, Inc.
%%
%% This file is provided to you under the Apache License,
%% Version 2.0 (the "License"); you may not use this file
%% except in compliance with the License.  You may obtain
%% a copy of the License at
%%
%%   http://www.apache.org/licenses/LICENSE-2.0
%%
%% Unless required by applicable law or agreed to in writing,
%% software distributed under the License is distributed on an
%% "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
%% KIND, either express or implied.  See the License for the
%% specific language governing permissions and limitations
%% under the License.
%%
%% -------------------------------------------------------------------
-module(bondy_security).
-include("bondy.hrl").
-include("bondy_security.hrl").
-include_lib("wamp/include/wamp.hrl").


%% TO BE REMOVED
-export([authenticate/4]).
-export([authenticate_anonymous/2]).
-export([check_permission/2]).
-export([check_permissions/2]).
-export([rbac_mod/1]).





%% =============================================================================
%% PRIVATE
%% =============================================================================


%% -----------------------------------------------------------------------------
%% @doc
%% @end
%% -----------------------------------------------------------------------------
-spec authenticate(
    RealmUri :: uri(),
    Username :: binary(),
    Password :: binary() | {hash, binary()},
    ConnInfo :: [{atom(), any()}]) ->
        {ok, context()} |
        {error,
            unknown_user
            | {no_such_realm, uri()}
            | bad_password
            | missing_password
            | no_matching_sources
        }.


authenticate(RealmUri, Username, Password, ConnInfo) ->
    try
        _ = bondy_realm:fetch(RealmUri),
        Uri = lowercase(RealmUri),
        Name = lowercase(Username),
        case user_details(Uri, Name) of
            undefined ->
                {error, unknown_user};
            Data ->
                M = #{
                    realm_uri => Uri,
                    username => Name,
                    password => Password,
                    conn_info => ConnInfo
                },
                auth_with_data(Data, M)
        end
    catch
        ?EXCEPTION(_, {not_found, RealmUri}, _) ->
            {error, {no_such_realm, RealmUri}}
    end.

%% -----------------------------------------------------------------------------
%% @doc
%% @end
%% -----------------------------------------------------------------------------
authenticate_anonymous(Uri, IP) ->
    Sources = bondy_rbac_source:match(Uri, anonymous),
    M0= #{
        realm_uri => Uri,
        username => anonymous,
        conn_info => [{ip, IP}]
    },

    case bondy_rbac_source:match_first(Sources, anonymous, IP) of
        {ok, trust, Opts} ->
            M1 = M0#{source_options => Opts},
            auth_with_source(trust, undefined, M1);
        {error, _} = Error ->
            Error
    end.

%% @private
auth_with_data(UserData, M0) ->
    Uri = maps:get(realm_uri, M0),
    User = maps:get(username, M0),

    Sources = bondy_rbac_source:match(Uri, User),
    IP = proplists:get_value(ip, maps:get(conn_info, M0)),

    case bondy_rbac_source:match_first(Sources, maps:get(username, M0), IP) of
        {ok, Source, Opts} ->
            M1 = M0#{source_options => Opts},
            auth_with_source(Source, UserData, M1);
        {error, _} = Error ->
            Error
    end.



%% @private
auth_with_source(?WAMP_ANON_AUTH, Data, M) ->
    auth_with_source(trust, Data, M);

auth_with_source(?TRUST_AUTH, Data, M) ->
    auth_with_source(trust, Data, M);

auth_with_source(trust, undefined, #{username := anonymous} = M) ->
    {ok, get_anonymous_context(M)};

auth_with_source(trust, _, M) ->
    %% trust always authenticates
    {ok, get_context(M)};

auth_with_source(?WAMP_COOKIE_AUTH, UserData, M) ->
    auth_with_source(password, UserData, M);

auth_with_source(?WAMP_TICKET_AUTH, UserData, M) ->
    auth_with_source(password, UserData, M);

auth_with_source(?WAMP_CRA_AUTH, UserData, M) ->
    auth_with_source(password, UserData, M);

auth_with_source(password, UserData, M) ->
    % pull the password out of the userdata
    try lookup(?PASSWORD, UserData) of
        undefined ->
            _ = lager:warning(
                "User is configured for password authentication, "
                "but has no password defined."
            ),
            {error, missing_password};

        PW0 ->
            %% We trigger a conditional upgrade to the password struct version
            %% if required.
            PW1 = maybe_upgrade_password(PW0, M),
            String = maps:get(password, M),
            Result = bondy_password:check_password(String, PW1),
            case Result of
                true ->
                    {ok, get_context(M)};
                false ->
                    {error, bad_password}
            end
    catch
        throw:Reason ->
            {error, Reason}
    end;

auth_with_source(Source, UserData, M) ->
    %% check for a dynamically registered auth module
    Opts = maps:get(source_options, M),
    AuthMods = application:get_env(bondy, auth_mods, []),
    Username = maps:get(username, M),
    case proplists:get_value(Source, AuthMods) of
        undefined ->
            _ = lager:warning(
                "User '~s' is configured with"
                " unknown authentication source '~s'",
                [Username, Source]),
            {error, unknown_source};
        AuthMod ->
            Password = maps:get(password, M),
            case AuthMod:auth(Username, Password, UserData, Opts) of
                ok ->
                    {ok, get_context(M)};
                error ->
                    {error, bad_password}
            end
    end.



maybe_upgrade_password(PW0, M) ->
    String = maps:get(password, M),
    case bondy_password:upgrade(String, PW0) of
        false ->
            PW0;
        {true, PW1} ->
            %% The password was upgraded, we store it
            RealmUri = maps:get(realm_uri, M),
            Username = maps:get(username, M),
            Result = bondy_rbac_user:update(
                RealmUri, Username, #{password => PW1}
            ),

            case Result of
                ok ->
                    _ = lager:debug("Password upgraded"),
                    PW1;
                {error, Reason} ->
                    _ = lager:debug("Error while trying to upgrade password"),
                    throw(Reason)
            end
    end.





